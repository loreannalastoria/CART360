//pressure pin

#define POT_PIN A0

//LED lights
#define RED_LED 10
#define BLUE_LED 11
#define GREEN_LED 9

//constant for size of running samples array (for averaging)
#define PRESSURE_SAMPLES 32

// timer vars
unsigned long timePassed;
unsigned long startTime;

//thresholds for medium press 
int thresholdOne = 650;
int thresholdTwo = 820;

//sensor value
unsigned int sensorValueFinal;
unsigned int sensorValueAverage;

// keep track of average Freq generated by the photocell
int averagePressureFrequency = 0;

// max pressing time
const int MAX_PRESS_TIME = 20000;
const int END_TIME = 30000;

int sum = 0;

//boolean for blinking
boolean doBlink;
boolean firstTimeIn = true;

//variables for red fading
int valueOverThresholdTwoFadeRed =0;
int speedFadeRed=6;

//variables for orange fading
int valueUnderThresholdTwoFadeOrangeR =0;
int valueUnderThresholdTwoFadeOrangeB=0;
int valueUnderThresholdTwoFadeOrangeG=0;
int speedFadeOrangeR=23;
int speedFadeOrangeB=1;
int speedFadeOrangeG=15;


//variables for blue fading
int valueUnderThresholdOneFadeBlueR =0;
int valueUnderThresholdOneFadeBlueB =0;
int valueUnderThresholdOneFadeBlueG =0;
int speedFadeBlueR =1;
int speedFadeBlueB =2;
int speedFadeBlueG =2;

void setup() {
  Serial.begin(9600);
}

void loop() {

  sensorValueAverage = analogRead(A0);
  //Serial.println(sensorValueAverage);

//enter no press (under threshold one)
  if (sensorValueAverage >= 0 && sensorValueAverage < thresholdOne) {
    valueOverThresholdTwoFadeRed =0;

    //reset for orange
    valueUnderThresholdTwoFadeOrangeR=0;
    valueUnderThresholdTwoFadeOrangeB= 0;
    valueUnderThresholdTwoFadeOrangeG= 0;
    speedFadeOrangeR=23;
    speedFadeOrangeB=1;
   speedFadeOrangeG=15;

     Serial.println("no press");
     //Serial.println(sensorValueAverage);

     //start timer for blink
    if (firstTimeIn == true)
    {
      startUpTimer();
      firstTimeIn = false;
    }

    //fade in fade out blue while less than 20 seconds
     if (timePassed <= MAX_PRESS_TIME) {

      //call color function for no press
     underTresholdOne();

      //speed of fade in fade out blue 
     valueUnderThresholdOneFadeBlueR+=speedFadeBlueR;
     Serial.println(valueUnderThresholdOneFadeBlueR);
     valueUnderThresholdOneFadeBlueB+=speedFadeBlueB;
     valueUnderThresholdOneFadeBlueG+=speedFadeBlueG;

  //start to fade out when reach it's peak value, vice versa
  //attributed by Sabine 
           if((valueUnderThresholdOneFadeBlueR>=103 && valueUnderThresholdOneFadeBlueB>=206  && valueUnderThresholdOneFadeBlueG>=154)
           ||(valueUnderThresholdOneFadeBlueR<=0 && valueUnderThresholdOneFadeBlueB<=2  && valueUnderThresholdOneFadeBlueG<=0))
          {
            speedFadeBlueR *= -1;
            speedFadeBlueB *= -1;
            speedFadeBlueG *= -1;
            
          }

          
     }

     //check how much time has passed 
     updateTimer();

     //after 20 seconds of being in no press mode, start blinking
    if (timePassed > MAX_PRESS_TIME && timePassed <= END_TIME) {
      doBlink = true;
      blinkAfterTimePassed();
    }

   //after 10 sec of blinking, shut down lights
    if (timePassed > END_TIME) {
      stopLightFunction();
    }

  }

//enter medium press mode
  else if (sensorValueAverage >= 600 && sensorValueAverage < thresholdTwo) {
    valueOverThresholdTwoFadeRed =0;

  //reset blue color fade
      valueUnderThresholdOneFadeBlueR =0;
      valueUnderThresholdOneFadeBlueB =0;
      valueUnderThresholdOneFadeBlueG =0;
      speedFadeBlueR =1;
      speedFadeBlueB =2;
      speedFadeBlueG =2;
    
      Serial.println("medium press");
      Serial.println(sensorValueAverage);
    doBlink = false;
    firstTimeIn = true;

    //speed of fade in fade out orange
    valueUnderThresholdTwoFadeOrangeR+=speedFadeOrangeR;
    valueUnderThresholdTwoFadeOrangeB+=speedFadeOrangeB;
    valueUnderThresholdTwoFadeOrangeG+=speedFadeOrangeG;

    //start to fade out when reach it's peak value, vice versa
    //attributed by Sabine 
    if(valueUnderThresholdTwoFadeOrangeR>=250 && valueUnderThresholdTwoFadeOrangeB>=11  && valueUnderThresholdTwoFadeOrangeG>=160)
    {
      speedFadeOrangeR *= -1;
      speedFadeOrangeB *= -1;
      speedFadeOrangeG *= -1;
      
    }
    if(valueUnderThresholdTwoFadeOrangeR<=5 && valueUnderThresholdTwoFadeOrangeB<=0  && valueUnderThresholdTwoFadeOrangeG<=5)
    {
      speedFadeOrangeR *= -1;
      speedFadeOrangeB *= -1;
      speedFadeOrangeG  *= -1;
      
    }

    //call color function for medium press
    underTresholdTwo ();
  }

  else {
    //reset for orange
    valueUnderThresholdTwoFadeOrangeR=0;
    valueUnderThresholdTwoFadeOrangeB= 0;
    valueUnderThresholdTwoFadeOrangeG= 0;
    speedFadeOrangeR=23;
    speedFadeOrangeB=1;
    speedFadeOrangeG=15;


    //reset blue color fade
      valueUnderThresholdOneFadeBlueR =0;
      valueUnderThresholdOneFadeBlueB =0;
      valueUnderThresholdOneFadeBlueG =0;
      speedFadeBlueR =1;
      speedFadeBlueB =2;
      speedFadeBlueG =2;
    
    Serial.println("hard press");
    Serial.println(sensorValueAverage);
    doBlink = false;
    firstTimeIn = true;

    //speed for red fade
    valueOverThresholdTwoFadeRed+=speedFadeRed;

    //start to fade out when reach it's peak value, vice versa
    //attributed by Sabine 
    if(valueOverThresholdTwoFadeRed>=150){
      speedFadeRed *= -1;
    }
    if(valueOverThresholdTwoFadeRed<=0){
      speedFadeRed *= -1;
    }

    //call color function for hard press
    overTresholdTwo();
  }
}

//reset timer
void startUpTimer() {
  //IMPLEMENT
  //set startTime to millis
  startTime = millis();

  //reset timePassed to 0
  timePassed = 0;
}

//function to check how much time has passed
void updateTimer()
{
  //IMPLEMENT
  //calculate how much time has passed since StartTime (time since pressed the button)
  timePassed = millis() - startTime;
}

//function for blinking led
void blinkAfterTimePassed() {

  //blink light blue
  if (doBlink) {
    analogWrite(RED_LED, 103);
    analogWrite(BLUE_LED, 244);
    analogWrite(GREEN_LED, 154);
    delay(1000);                      // wait for a second
    analogWrite(RED_LED, 0);
    analogWrite(BLUE_LED, 0);
    analogWrite(GREEN_LED, 0);
    delay(1000);
  }

}

//function to stop all lights
void stopLightFunction(){
  
  analogWrite(RED_LED, 0);
    analogWrite(BLUE_LED, 0);
    analogWrite(GREEN_LED, 0);
  
}

//sensorValue from 0-650
void underTresholdOne () {
  //pillow is blue
  analogWrite(RED_LED, valueUnderThresholdOneFadeBlueR);
  analogWrite(BLUE_LED, valueUnderThresholdOneFadeBlueB);
  analogWrite(GREEN_LED, valueUnderThresholdOneFadeBlueG);
  delay(100);

}

//sensorValue from 650-820
void underTresholdTwo () {
  //pillow turns orange
  analogWrite(RED_LED, valueUnderThresholdTwoFadeOrangeR);
  analogWrite(BLUE_LED, valueUnderThresholdTwoFadeOrangeB);
  analogWrite(GREEN_LED, valueUnderThresholdTwoFadeOrangeG);
  delay(130);

}

//sensorValue from 820-1023
void overTresholdTwo () {
  //pillow turns red
  analogWrite(RED_LED, valueOverThresholdTwoFadeRed);
  analogWrite(BLUE_LED, 0);
  analogWrite(GREEN_LED, 0);
  delay(100);

}

